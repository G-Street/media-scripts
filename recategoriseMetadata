#! /usr/local/bin/bash

# ensure you run:
# `pkg install bash python3 ffmpeg`

# MEDIA_DIR="/mnt/Primary/Media"
MEDIA_DIR="/mnt/Media/"
LOGFILE="${MEDIA_DIR}/Scripts/conversion.log"
ALBUM_LOG="${MEDIA_DIR}/Scripts/albums.log"
FAILED="${MEDIA_DIR}/Scripts/failed.log"

source "${MEDIA_DIR}/Scripts/scriptlets/helpCommands"
source "${MEDIA_DIR}/Scripts/scriptlets/optionErrors"
source "${MEDIA_DIR}/Scripts/scriptlets/jsonColourParser"


display_help() {
    help_start 'recategoriseMetadata [-h]' 'The present script will find all films that exist in subdirectories with a unified parent subdirectory under Movies/, and add an album tag to then so that Plex will recognise them as a category.'
    help_help '2'
}


dirHasFiles() {
    dir=${1:-.}
    
    for f in "${dir}"/* "${dir}"/.[!.]* "${dir}"/..?*
    do
        [ -d "${f}" ] && continue
        [ -e "${f}" ] && return 0
    done
    
    return 1
}


getAlbumName() {
    /usr/local/bin/ffprobe -loglevel quiet -show_format "${1}" | awk -F'=' '/album/ {print $2}'
}


findValidCategory() {
    [[ ! -d /tmp/categorisingFilms/ ]] && \
        mkdir -p /tmp/categorisingFilms/
    
    find $(cd "${MEDIA_DIR}/Movies/"; pwd) -type d -print |
    while IFS= read -r directory
    do
        CATEGORY_NAME="$(basename -- "$(dirname -- "${directory}")")"
        
        # check that the found directory a) has files in it;
        # b) has a parent that doesn not have files in it;
        # c) has a parent whose name is not "Movies";
        # and d) has a parent whose name is not "Media"
        if dirHasFiles "${directory}" && ! dirHasFiles "${directory}/.." && [[ "${CATEGORY_NAME}" != "Movies" ]] && [[ "${CATEGORY_NAME}" != "Media" ]]
        then
            
            PATH_NAME="$(readlink -f "${directory}/..")" # readlink required to expand ..
            printf "${CATEGORY_NAME}\t${PATH_NAME}/\n" # using tab in case names have commas in them
        fi
    done | sort | uniq > /tmp/categorisingFilms/categories.csv
}


main() {
    truncate -s0 "${LOGFILE}"
    truncate -s0 "${ALBUM_LOG}"
    truncate -s0 "${FAILED}"

    while IFS=$'\t' read -r ALBUM_NAME collectionPath # col1 col2
    do
        find "${collectionPath}" -type f \( -iname \*.mkv -o -iname \*.avi -o -iname \*.mp4 \) -print | \
        while IFS= read -r film; do
            RAW_FILE_NAME="$(basename -- "${film}")"
            EXT="${RAW_FILE_NAME##*.}"
        
            OLD_ALBUM_NAME="$(getAlbumName "${film}")"
        
            # only convert album name if not already what we desire
            if [[ "${OLD_ALBUM_NAME}" == "${ALBUM_NAME}" ]]
            then
                :
            else
        
                TEMP_NAME="${film}.album.${EXT}"
        
                # add album name to new temp file
                < /dev/null ffmpeg -nostdin -y -i "${film}" -codec copy -metadata album="${ALBUM_NAME}" "${TEMP_NAME}" 2>> "${LOGFILE}"
        
                # rename temp file to other file and remove old
                if [[ -f "${TEMP_NAME}" ]]; then
                    rm "${film}" && mv "${TEMP_NAME}" "${film}"
                else
                    echo "Failed to edit the metadata of ${film}.  Wade through ${LOGFILE} for details." >> "${FAILED}"
                fi
        
                # print new album name to log file
                NEW_ALBUM_NAME="$(getAlbumName "${film}")"
                
                echo "Converted ${RAW_FILE_NAME}: Album tag \"${OLD_ALBUM_NAME}\" changed to \"${NEW_ALBUM_NAME}\"." >> "${ALBUM_LOG}"
        
            fi
        done
    done < /tmp/categorisingFilms/categories.csv
}


OPTIND=1
while getopts ":-:h" OPTION; do
        case $OPTION in
                -)
                    case $OPTARG in
                        help)
                            display_help ;;
                        *)
                            opt_err ;;
                    esac ;;
                h)
                    display_help ;;
                *)
                    opt_err ;;
        esac
done


if [[ "${1}" =~ ^\-.+ ]] # checks to see if first argument begins with a minus (i.e., is an option) as we cannot assess $OPTIND before options are called
then
    :
else
    start=$(python3 -c 'import time; print(time.time())')
    findValidCategory
    main
    end=$(python3 -c 'import time; print(time.time())')
    runtime=$(echo "( $end - $start ) / 60" | bc -l )
    echo "++++++ FINISHED CONVERSIONS in ${runtime} minutes at $(date) ++++++" >> "${LOGFILE}"
fi
